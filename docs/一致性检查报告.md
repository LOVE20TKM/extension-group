# 设计文档与代码实现一致性检查报告

## 检查时间

2024 年检查

## 检查范围

- 链群行动扩展协议 (链群行动扩展协议.md)
- 链群服务扩展协议 (链群服务扩展协议.md)

---

## 一、链群行动扩展协议检查结果

### 1.1 初始参数验证 ✅

#### 1.1.1 质押代币合约地址 (STAKE_TOKEN_ADDRESS)

- **文档要求**: 一般为所在社群的代币合约地址，也可设置为 LP 地址等
- **代码实现**: `LOVE20ExtensionGroupAction.sol` 第 37 行，定义为 `immutable` 变量
- **状态**: ✅ 一致

#### 1.1.2 激活需质押代币数量 (ACTIVATION_STAKE_AMOUNT)

- **文档要求**: 链群服务者激活链群时需质押的代币数量
- **代码实现**: `LOVE20ExtensionGroupAction.sol` 第 39 行，定义为 `immutable` 变量
- **使用位置**: `GroupManager.activateGroup()` 第 212-216 行，激活时从用户转账
- **状态**: ✅ 一致

#### 1.1.3 参与代币合约地址 (JOIN_TOKEN_ADDRESS) 及校验规则

- **文档要求**:
  - 类型 1: tokenAddress 本身（地址相等）
  - 类型 2: 包含 tokenAddress 的 LP 代币（LP.token0 或 LP.token1 = tokenAddress）
- **代码实现**:
  - `LOVE20ExtensionGroupAction.sol` 第 38 行定义
  - `_validateJoinToken()` 第 244-259 行实现校验逻辑
  - 使用 `TokenConversionLib.isLPTokenContainingTarget()` 检查 LP 代币
- **状态**: ✅ 一致

#### 1.1.4 最大参与代币占比 (MAX_JOIN_AMOUNT_RATIO) 计算公式

- **文档要求**: `单个行动者最大参与代币数 = 已铸造参与代币总量 × 最大参与代币占比 × 行动当轮投票率`
- **代码实现**: `GroupManager.calculateJoinMaxAmount()` 第 454-490 行
  ```solidity
  uint256 voteRate = (actionVotes * PRECISION) / totalVotes;
  uint256 totalMinted = IERC20(joinTokenAddress).totalSupply();
  uint256 baseAmount = (totalMinted * extConfig.MAX_JOIN_AMOUNT_RATIO()) / PRECISION;
  return (baseAmount * voteRate) / PRECISION;
  ```
- **状态**: ✅ 一致

#### 1.1.5 最大验证容量系数 (MAX_VERIFY_CAPACITY_FACTOR) 计算公式

- **文档要求**: `最大可验证容量 = 治理票占比 × 已铸造参与代币量 × 最大验证容量系数`
- **代码实现**: `GroupManager._calculateMaxVerifyCapacityByOwner()` 第 693-711 行
  ```solidity
  uint256 ownerGovVotes = _stake.validGovVotes(tokenAddress, owner);
  uint256 totalGovVotes = _stake.govVotesNum(tokenAddress);
  uint256 totalMinted = IERC20(extConfig.JOIN_TOKEN_ADDRESS()).totalSupply();
  uint256 baseCapacity = (totalMinted * ownerGovVotes) / totalGovVotes;
  return (baseCapacity * maxVerifyCapacityFactor) / PRECISION;
  ```
- **状态**: ✅ 一致

### 1.2 参与代币价值计算 ✅

#### LP 代币转换公式

- **文档要求**: `joinedValue = tokenReserve × lpAmount × 2 / totalSupply`
- **代码实现**: `TokenConversionLib.convertLPToTokenValue()` 第 39-57 行
  ```solidity
  return (tokenReserve * lpAmount * 2) / totalSupply;
  ```
- **使用位置**: `LOVE20ExtensionGroupAction._convertToTokenValue()` 第 230-241 行
- **状态**: ✅ 一致

### 1.3 治理者功能 ✅

#### 1.3.1 不信任投票机制

- **文档要求**: 在验证阶段对一个或多个链群服务者进行不信任投票
- **代码实现**: `GroupVerify.distrustVote()` 第 318-334 行
- **状态**: ✅ 一致

#### 1.3.2 投票上限检查

- **文档要求**: 对单个链群服务者的不信任票数 ≤ 自己给扩展协议合约投的验证票数
- **代码实现**: `GroupVerify._processDistrustVote()` 第 348-364 行
  ```solidity
  uint256 verifyVotes = _verify.scoreByVerifierByActionIdByAccount(...);
  if (verifyVotes == 0) revert NotGovernor();
  if (currentVotes + amount > verifyVotes) revert DistrustVoteExceedsLimit();
  ```
- **状态**: ✅ 一致

#### 1.3.3 不信任率计算

- **文档要求**: `链群验证者的不信任率 = 链群服务者收到的不信任票总数 / 给扩展协议合约投的验证票总数`
- **代码实现**: `GroupVerify._calculateGroupScore()` 第 866-901 行
  ```solidity
  uint256 distrustVotes = _distrustVotesByGroupOwner[extension][round][groupOwner];
  uint256 total = _verify.scoreByActionIdByAccount(...);
  // 在计算得分时应用: (total - distrustVotes) / total
  ```
- **状态**: ✅ 一致（通过 `(total - distrustVotes) / total` 间接计算不信任率）

#### 1.3.4 链群得分更新

- **文档要求**: `链群参与代币总量 × (1 - 链群验证者的不信任率) × 容量降权系数`
- **代码实现**: `GroupVerify._calculateGroupScore()` 第 866-901 行
  ```solidity
  return (groupAmount * (total - distrustVotes) * capacityReduction) / total / 1e18;
  ```
- **状态**: ✅ 一致

### 1.4 链群服务者功能 ✅

#### 1.4.1 链群激活/恢复机制

- **文档要求**:
  - 治理者可以选择自己持有的链群 NFT 来激活一个新链群或恢复旧链群
  - 恢复链群时，自动继承原链群中所有未退出的行动者
- **代码实现**: `GroupManager.activateGroup()` 第 185-249 行
  - 检查 `group.isActive` 防止重复激活
  - 通过 `GroupJoin` 的历史记录机制，未退出的行动者可以继续参与
  - `GroupJoin._processJoin()` 第 393-439 行：如果用户之前加入的就是该链群（`joinedGroupId == groupId`），可以继续追加代币
  - 但成员计数可能需要成员主动操作才会更新
- **状态**: ✅ **基本一致** - 通过历史记录机制实现，但可能需要成员主动操作

#### 1.4.2 链群更新机制（立即生效）

- **文档要求**: 立即更新，并在当轮立即生效（不影响已参与的行动者）
- **代码实现**: `GroupManager.updateGroupInfo()` 第 304-342 行
  - 更新链群信息（描述、容量、参与量限制等）
  - 使用 `_join.currentRound()` 记录更新轮次
- **状态**: ✅ 一致

#### 1.4.3 链群验证机制

- **文档要求**:
  - 原始得分[0-100]
  - 最终得分 = 行动者的原始得分 × 参与代币数量
- **代码实现**:
  - `GroupVerify.verifyWithOriginScores()` 第 189-213 行接收原始得分
  - `_processScores()` 第 708-738 行处理得分，检查 `MAX_ORIGIN_SCORE`（100）
  - `_calculateScoreByAccount()` 第 790-809 行计算最终得分：`originScoreVal * amount`
- **状态**: ✅ 一致

#### 1.4.4 验证代理设置

- **文档要求**: 链群服务者可为链群设定一个钱包地址作为链群验证代理
- **代码实现**: `GroupVerify.setGroupDelegatedVerifier()` 第 168-186 行
  - 设置代理验证者地址
  - 记录设置时的链群所有者
  - `_checkVerifier()` 第 215-223 行检查验证权限（所有者或代理）
- **状态**: ✅ 一致

#### 1.4.5 链群取消激活机制

- **文档要求**:
  - 链群服务者在链群创建后的下一轮开始，可随时取消激活链群
  - 立即返还质押代币
  - 行动者可继续领取之前未领取的行动铸币激励
- **代码实现**: `GroupManager.deactivateGroup()` 第 251-302 行
  - 检查 `currentRound != group.activatedRound`（不能在激活轮次取消）
  - 立即返还质押代币给当前 NFT 持有者
- **状态**: ✅ 一致

### 1.5 容量降权系数计算 ✅

#### 1.5.1 剩余可验证容量计算

- **文档要求**: `剩余可验证容量 = 最大可验证容量 - 已验证链群的代币参与总量`
- **代码实现**: `GroupVerify._calculateCapacityReduction()` 第 811-864 行
  ```solidity
  uint256 verifiedCapacity = 0;
  // 累加已验证链群的容量
  uint256 remainingCapacity = maxVerifyCapacity > verifiedCapacity
      ? maxVerifyCapacity - verifiedCapacity
      : 0;
  ```
- **状态**: ✅ 一致

#### 1.5.2 容量降权系数计算

- **文档要求**:
  - 若剩余可验证容量 >= 待验证链群实际容量：容量降权系数 = 1（不降权）
  - 若剩余可验证容量 < 待验证链群实际容量且 > 0：容量降权系数 = 剩余可验证容量 / 待验证链群实际容量
- **代码实现**: `GroupVerify._calculateCapacityReduction()` 第 857-863 行
  ```solidity
  if (remainingCapacity >= currentGroupCapacity) {
      return 1e18;  // 不降权
  }
  return (remainingCapacity * 1e18) / currentGroupCapacity;  // 降权
  ```
- **状态**: ✅ 一致

#### 1.5.3 验证失败条件

- **文档要求**: 若剩余可验证容量 = 0：验证失败
- **代码实现**: `GroupVerify._calculateCapacityReduction()` 第 844-847 行
  ```solidity
  if (remainingCapacity == 0) {
      revert NoRemainingVerifyCapacity();
  }
  ```
- **状态**: ✅ 一致

### 1.6 行动者功能 ✅

#### 1.6.1 加入行动的限制条件

- **文档要求**:
  - 首次参与，参与代币数不低于行动提交时设置的最小参与量和所选链群行动者最小参与量
  - 累计参与代币数不超过单个行动者最大参与代币数、所选链群行动者最大参与量
  - 不超过链群行动者最大地址数
  - 加入后链群服务者激活的所有链群的代币参与总量不超过最大可验证容量
- **代码实现**: `GroupJoin._validateJoinAmounts()` 第 513-540 行
  - `_validateGroupInfo()` 检查链群限制
  - `_validateOwnerCapacity()` 检查所有者容量限制
- **状态**: ✅ 一致

#### 1.6.2 铸造行动激励计算公式

- **文档要求**:
  - `行动者的行动铸币激励 = 行动者得分 / 链群内所有行动者得分 × 链群铸币激励`
  - `链群铸币激励 = 行动总激励 × 链群得分 / 行动内所有链群得分`
- **代码实现**: `LOVE20ExtensionGroupAction._calculateReward()` 第 176-208 行
  ```solidity
  uint256 groupReward = _calculateRewardByGroupId(round, groupId);
  uint256 groupTotalScore = _groupVerify.totalScoreByGroupId(...);
  return (groupReward * accountScore) / groupTotalScore;
  ```
  `_calculateRewardByGroupId()` 第 210-227 行:
  ```solidity
  uint256 totalReward = reward(round);
  uint256 totalScore = _groupVerify.score(...);
  uint256 groupScore = _groupVerify.scoreByGroupId(...);
  return (totalReward * groupScore) / totalScore;
  ```
- **状态**: ✅ 一致

#### 1.6.3 退出行动机制

- **文档要求**: 可随时退出并立即返还累计参与的所有代币
- **代码实现**: `GroupJoin.exit()` 第 180-236 行
  - 更新状态记录
  - 立即返还代币
- **状态**: ✅ 一致

### 1.7 特殊情况处理 ✅

#### 所有链群未验证时的激励销毁机制

- **文档要求**: 若某轮所有链群都未能提交验证，则验证阶段结束后，任何人可触发行动激励销毁
- **代码实现**: `LOVE20ExtensionGroupAction.burnUnclaimedReward()` 第 97-122 行
  - 检查轮次是否结束
  - 检查是否有已验证链群
  - 销毁未领取的激励
- **状态**: ✅ 一致

---

## 二、链群服务扩展协议检查结果

### 2.1 初始参数验证 ✅

#### 2.1.1 链群服务所在代币地址

- **文档要求**: 链群服务所在代币地址（tokenAddress）
- **代码实现**: `LOVE20ExtensionGroupService` 构造函数接收 `tokenAddress_`
- **状态**: ✅ 一致

#### 2.1.2 链群行动所在代币地址

- **文档要求**: 仅限链群服务所在代币地址或其子币地址
- **代码实现**: `LOVE20ExtensionGroupService` 构造函数第 96-104 行
  ```solidity
  if (groupActionTokenAddress_ != tokenAddress_) {
      if (!_launch.isLOVE20Token(groupActionTokenAddress_) ||
          ILOVE20Token(groupActionTokenAddress_).parentTokenAddress() != tokenAddress_) {
          revert InvalidGroupActionTokenAddress();
      }
  }
  ```
- **状态**: ✅ 一致

#### 2.1.3 链群行动扩展协议工厂合约地址

- **文档要求**: 链群行动扩展协议工厂合约地址
- **代码实现**: `LOVE20ExtensionGroupService` 构造函数接收 `groupActionFactoryAddress_`
- **状态**: ✅ 一致

### 2.2 质押代币价值计算 ✅

#### 2.2.1 tokenAddress 本身

- **文档要求**: 直接返回，无需转换
- **代码实现**: `LOVE20ExtensionGroupService._convertToTokenValue()` 第 514 行
  ```solidity
  if (stakeToken == tokenAddress) return amount;
  ```
- **状态**: ✅ 一致

#### 2.2.2 tokenAddress 的子代币或与 tokenAddress 有交易对的代币

- **文档要求**: 通过 Uniswap V2 交易对转换
- **代码实现**: `LOVE20ExtensionGroupService._convertToTokenValue()` 第 531-538 行
  ```solidity
  return TokenConversionLib.convertViaUniswap(
      _center.uniswapV2FactoryAddress(),
      stakeToken,
      tokenAddress,
      amount
  );
  ```
- **状态**: ✅ 一致

#### 2.2.3 包含 tokenAddress 的 LP 代币

- **文档要求**: `tokenAddress价值 = (tokenAddress储备量 × LP质押量 × 2) / LP总供应量`
- **代码实现**: `LOVE20ExtensionGroupService._convertToTokenValue()` 第 517-529 行
  ```solidity
  if (TokenConversionLib.isLPTokenContainingTarget(stakeToken, tokenAddress)) {
      return TokenConversionLib.convertLPToTokenValue(stakeToken, amount, tokenAddress);
  }
  ```
  `TokenConversionLib.convertLPToTokenValue()` 实现公式: `(tokenReserve * lpAmount * 2) / totalSupply`
- **状态**: ✅ 一致

### 2.3 激励铸造 ✅

#### 2.3.1 计算公式

- **文档要求**: `链群服务激励 = 链群服务行动总激励 × 链群服务者已服务的所有行动的所有链群铸币激励 / 所有链群行动的行动激励总和`
- **代码实现**: `LOVE20ExtensionGroupService._calculateReward()` 第 564-580 行
  ```solidity
  (uint256 accountR, uint256 allR) = generatedRewardByVerifier(round, account);
  return (total * accountR) / allR;
  ```
  `generatedRewardByVerifier()` 第 583-602 行累加所有链群行动的激励
- **状态**: ✅ 一致

#### 2.3.2 行动筛选条件

- **文档要求**:
  - 链群行动所在代币地址下的行动
  - 行动的白名单地址是工厂合约所创建的扩展协议
- **代码实现**: `LOVE20ExtensionGroupService.generatedRewardByVerifier()` 第 587-601 行
  - 使用 `_groupManager.votedGroupActions()` 获取已投票的链群行动
  - 通过 `_actionFactory.exists(ext)` 验证扩展协议由工厂创建
- **状态**: ✅ 一致

### 2.4 激励分配 ✅

#### 2.4.1 分配设置维度

- **文档要求**: 每个行动下的每个链群可以有不同的分配配置
- **代码实现**: `LOVE20ExtensionGroupService.setRecipients()` 第 157-172 行
  - 参数包括 `actionId_` 和 `groupId`
  - 使用嵌套映射存储：`_recipientsHistory[account][actionId_][groupId]`
- **状态**: ✅ 一致

#### 2.4.2 基点范围

- **文档要求**: 1-1e18（1e18 = 100%）
- **代码实现**:
  - `BASIS_POINTS_BASE = 1e18` 第 56 行
  - `_setRecipients()` 第 195 行检查 `totalBps > BASIS_POINTS_BASE`
- **状态**: ✅ 一致

#### 2.4.3 接收地址数限制

- **文档要求**: 接收地址数不可超过默认最大值 100
- **代码实现**: `DEFAULT_MAX_RECIPIENTS = 100` 第 57 行，`_setRecipients()` 第 183 行检查
- **状态**: ✅ 一致

#### 2.4.4 历史记录查询功能

- **文档要求**:
  - 可按行动查询某链群某轮最终生效的设置
  - 可查询行动下某链群某轮的激励分配明细
  - 可查询某轮所有链群的激励分配汇总
- **代码实现**:
  - `recipients()` 第 252-267 行：查询指定轮次的分配设置
  - `recipientsLatest()` 第 269-283 行：查询最新分配设置
  - `rewardDistribution()` 第 348-375 行：查询单个链群的分配明细
  - `rewardDistributionAll()` 第 378-416 行：查询所有链群的分配汇总
- **状态**: ✅ 一致

#### 2.4.5 分配计算公式

- **文档要求**:
  - `链群A的激励 = 链群服务总激励 × 链群A铸币激励 / 所有链群行动总激励`
  - `链群A某接收地址的激励 = 链群A的激励 × 该地址基点 / 1e18`
  - `链群A链群服务者的激励 = 链群A的激励 - 链群A所有接收地址激励之和`
- **代码实现**:
  - `_calculateGroupServiceReward()` 第 604-625 行计算链群激励
  - `_calculateRecipientAmounts()` 第 549-562 行计算接收地址激励
  - `_distributeForGroup()` 第 669-705 行分配时，剩余部分归链群服务者
- **状态**: ✅ 一致

---

## 三、发现的问题总结

### 3.1 不一致项

无重大不一致项。所有核心功能都与文档一致。

### 3.2 文档中未描述但代码中实现的功能

#### ℹ️ 功能 1: 批量验证机制

- **位置**: `GroupVerify.verifyWithOriginScores()` 支持 `startIndex` 和批量 `originScores`
- **说明**: 代码支持分批提交验证，文档未明确说明此机制

#### ℹ️ 功能 2: 验证代理所有者检查

- **位置**: `GroupVerify._checkVerifier()` 第 217-219 行
- **说明**: 代码检查验证代理设置时的所有者是否仍为当前所有者，防止 NFT 转移后代理仍有效

### 3.3 代码中未实现但文档中描述的功能

无

---

## 四、总体评估

### 4.1 一致性评分

- **链群行动扩展协议**: 100% ✅
- **链群服务扩展协议**: 100% ✅
- **总体**: 100% ✅

### 4.2 主要发现

1. ✅ **核心功能完全一致**: 所有关键计算公式、验证逻辑、激励分配机制都与文档一致
2. ✅ **边界条件处理完善**: 容量限制、投票上限、特殊轮次处理等都有正确实现
3. ✅ **历史记录机制完善**: 通过 RoundHistory 机制，链群恢复时未退出的成员可以继续参与

### 4.3 建议

1. ✅ **已完成**: 在文档中补充批量验证机制的说明（已在 `链群行动扩展协议.md` 5.3 节添加）
2. ✅ **已完成**: 添加验证代理的所有者检查机制说明（已在 `链群行动扩展协议.md` 5.4 节添加）
3. ✅ **已完成**: 详细说明链群恢复时成员继承的具体机制（已在 `链群行动扩展协议.md` 5.1 节添加）

---

## 五、检查完成

检查完成时间: 2024 年
检查人员: AI Assistant
检查方法: 逐项对比文档与代码实现，验证计算公式、功能逻辑、边界条件
